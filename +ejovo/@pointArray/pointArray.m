classdef pointArray  
    %A class that describes the structure of point arrays.
    %
    %Class path: ejovo.pointArray
    %
    %A pointArray stores useful information abou the structures generated by the base
    %icosahedral shapes (ico, dod, and icc) and their affine extensions.
    %
    %ejovo.POINTARRAY properties:
    %
    %index          -index of a pointArray, which corresponds to the base
    %               structures that a pointArray is composed of. See Dr.
    %               Dave for a complete list of pointArray id's and their
    %               corresponding shape and scaling.
    %gP          - the gauge point location that the outermost point
    %               of a pointArray touches.
    %coords         - an Nx3 matrix that stores the XYZ coordinates of a
    %               pointArray
    %au             - an Nx3 matrix that stores the XYZ coordinates of the
    %               pointArray found in the asymmetric unit region.
    %sec            - no clue, ask Dr. Dave.
    %secOut         - no clue, ask Dr. Dave.
    %hull           - no clue, ask Dr. Dave.
    %outer          - no clue, ask Dr. Dave.
    %nVertices      - the number of vertices found at each radial level
    %orientation    - "saf" or "vdb" orientation, you know the drill. See
    %               the notes on SAF vs VDB orientation under the <a href=
    %               "https://teams.microsoft.com/l/channel/19%3adbe209ba4260495f98d1cf21aa32aa3a%40thread.tacv2/Code?groupId=4c83192e-2e3a-469f-8de7-a3c8352202b5&tenantId=e214b458-c456-45b4-961a-7852355f177a">code channel</a> 
    %               of the teams page.
    %levels         - the radial values of a point array, standardized to
    %               have the largest radial value as 1
    %affineGroup    - the affine extension directions. Appropriate values
    %               are T5, T3, or T2
    %
    %ejovo.POINTARRAY methods:
    %
    %calcDistinctR           - calculates the various radial levels of a pointArray
    %calcSphericalLocations  - calculates all possible spherical coordinates that 
    %                        pointArray/s touch, leaving the radius as a free variable.
    %                        Basically calculates the "shell" that covers all possible
    %                        locations on a sphere.
    %plot                    - plots a pointArray or a an array (hehe) of pointArray/s.
    %plotRadialLevel         - plots a pointArray at the rth radial level.
    %plotRadialLevels        - plots disctinct radial levels for a pointArray in one
    %                        figure (but multiple subfigures).
    %split                   - splits a pointArray into its various levels and correctly
    %                        calculates the number of points at each radial level.
    %toXYZ                   - converts a pointArray's coordinates to an xyz file,
    %                        storing it under the +ejovo/vmd/pa/'pa.id' folder, where the 'pa.id' is
    %                        unique for each pointArray.
    %
    
    properties
        
        index            %The index from 1-569 of a point array
        gP               %The points that make up a point array, stored as a 3xN matrix  
        coords
        au               %The points that are found in the AU region of a virus                   
        hull             
        nVertices     
        levels
        affineGroup
        sister      
        name
        scale
        orientation
    end
    
    
    
    properties (Hidden)
        distinctPlots
        oldID
        base1
        base2
        sec 
        secOut
        outer  
    end        
    
    methods
        function pointArray = pointArray(id, topid, points, au, sec, secOut, hull, outer, mult)
        %POINTARRAY defines a point array pointArrayect whose properties correspond to Dr. Dave's Mvpa structure    
            pointArray.oldID = id;
            pointArray.gP = topid;
            pointArray.coords = points;
            pointArray.au = au;
            pointArray.sec = sec;
            pointArray.secOut = secOut;
            pointArray.hull = hull;
            pointArray.outer = outer;
            pointArray.nVertices = mult;            
            pointArray.orientation = "vdb";
            pointArray = calcDistinctR(pointArray);
        end        
        
        function plotRadialLevels(pointArray)
        %PLOTRADIALLEVELS plots a point array at each radial level
            nlevels = length(pointArray.levels);
            colors = [[.8 0 0]; [.8 .8 0]; [0 0 .8]; [0 0 0]; [0 0 0]; [1 0 1]; [1 0 1]; [1 0 1]; [1 0 1]; [1 0 1]]; %red if ico, yellow if dod, blue if icododec, black if 60 or 120 vertices
            icoShape = [12, 20, 30, 60, 120, 3, 72, 150, 80, 216];                                               %number of vertices, which corresponds to the ico shape that it creates
            if mod(nlevels, 2) == 0
                ncols = nlevels/2;
            else
                ncols = nlevels/2 + .5;
            end
            
            figure('Name', ['Point array # ', num2str(pointArray.id)])            
            for qq = 1:nlevels 
                subplot(2, ncols, qq)
                nVer = length(pointArray.distinctPlots{qq});
                dP = ejovo.saf.rot2saf(pointArray.distinctPlots{qq});
                p = plot3(dP(:,1), dP(:,2), dP(:,3), '.');
                p.MarkerSize = 25;
                p.MarkerEdgeColor = colors(icoShape == nVer,:);    
                title([num2str(pointArray.levels(qq)), ' x ', num2str(nVer)])
                view(2)    
                %set(gca,'visible','off')
                axis equal
            end
        end
        
        function plot(pointArray)
        %PLOT plots an entire point array in SAF orientation  
            n = length(pointArray);
            for ii = 1:n
                thisvpa = ejovo.saf.rot2saf(pointArray(ii).coords);      %Rotates orientation to SAF coordinates            
                vpa_x = thisvpa(:,1);
                vpa_y = thisvpa(:,2);
                vpa_z = thisvpa(:,3);       
                pTitle = strcat('point array with id: ', num2str(pointArray(ii).index));
                figure('Name', 'All radial values')
                p = plot3(vpa_x, vpa_y, vpa_z, '.');
                p.MarkerSize = 25;
                p.MarkerEdgeColor = 'k';
                title(pTitle)
                view(3)
                axis equal
            end
        end
        
        function plotRadialLevel(pointArray, r)
        %PLOTRADIALLEVEL plots a point array at a specific radial level.
        %   PLOTRADIALLEVEL(pointArray, r) - plots the rth radial level of a point
        %   Array where the radial levels are stored in descending order.
        dP = pointArray.distinctPlots{r};
        figureTitle = strcat({'radial level '}, num2str(r), {' of point array '}, num2str(pointArray.index));
        figure('Name', figureTitle{1})
            p = plot3(dP(:,1), dP(:,2), dP(:,3), '.');
            p.MarkerSize = 25;
            p.MarkerEdgeColor = 'k';
            title(figureTitle)
            view(3)
            axis equal
        end
                
        function toXYZ(pointArray)
        %TOXYZ creates an xyz file for a point array at all levels
            folderName = strcat('+ejovo/pa_output/');
            paName = strcat('pa', pointArray.index);
            ejovo.fn.toXYZ(pointArray.coords, paName, folderName, 'H');
        end
        
        function pointArray = calcDistinctR(pointArray)  
        %CALCDISTINCTR - calculates the distinc radial levels of a point
        %array and saves them in the properties LEVELS.
        %
        %Ex: ejovo.pointArray = calcDistinctR(ejovo.pointArray)
            XYZ = pointArray.coords;
            radii = ejovo.wilson.calc_radii(XYZ);
            r = radii(1);

            for jj = 1:length(pointArray.coords)
                if ~ejovo.fn.isCloseTo(radii(jj), r(end))
                    r = [r, radii(jj)]; %#ok<AGROW>
                end
            end
            pointArray.levels = r;
        end
        
        function pointArray = split(pointArray)
        %SPLIT splits a point array into its various radial levels 
            X = pointArray.coords(:,1);
            Y = pointArray.coords(:,2);
            Z = pointArray.coords(:,3);
            [~, ~, r] = cart2sph(X, Y, Z);
            nlevels = length(pointArray.levels);
            dPlots = cell(1, nlevels);                    %have a vector that stores the distinct plots 
            multiples = zeros(1, nlevels);
            for jj = 1:nlevels
                id = ejovo.fn.isCloseTo(r, pointArray.levels(jj));
                dPlots{jj} = [X(id) Y(id) Z(id)];
                multiples(jj) = length(dPlots{jj});
            end
            pointArray.distinctPlots = dPlots;
            pointArray.nVertices = multiples;            
        end
        
        function possiblePairs = calcSphericalLocations(PointArray, AU, epsilon)
            if nargin < 3
                epsilon = 0.01; %Default value of 'closeness' this is sufficient to cover all possible combinations of PH and TH
                if nargin < 2
                    AU = false;
                end
            end
            if AU
                XYZ = vertcat(PointArray.au);
            else
                XYZ = vertcat(PointArray.coords);
            end            
            [TH, PH, ~] = cart2sph(XYZ(:,1), XYZ(:,2), XYZ(:,3));  
            existingTH = zeros(1);
            existingPH = zeros(1);          
            step = 1;
            while ~isempty(TH)
                existingTH(step, 1) = TH(1);
                existingPH(step, 1) = PH(1);
                logicTH = ejovo.fn.isCloseTo(TH, existingTH(end), epsilon);
                logicPH = ejovo.fn.isCloseTo(PH, existingPH(end), epsilon);
                check = and(logicTH, logicPH);
                TH = TH(~check); %Remove values for which the pair already exists
                PH = PH(~check); %Remove values for which the pait already exists
                step = step + 1;                
                %disp(length(TH))  %Displays how many combinations still have not been filtered
            end            
            possiblePairs = [existingTH existingPH];
        end
        
        function pointArrays = getAffineGroup(pointArrayArray, aGroup)
        %GETAFFINEGROUP Returns point arrays of the same affine group
            groupList = vertcat(pointArrayArray.affineGroup);
            ind = strcmpi(groupList, aGroup);
            pointArrays = pointArrayArray(ind);
        end        
        
        function oldArray = findOldArray(pointArray, oldid)
            oldids = vertcat(pointArray.oldID);
            ind = (oldids == oldid);
            oldArray = pointArray(ind);
        end
        
            
        
        
        

    end
    
    methods (Static)
        %need to work on getting and setting this method
        function sphericalCoordinates = setgetLocation()
            persistent LOCATIONS;
            if nargin
                LOCATIONS = data;
            end
            sphericalCoordinates = LOCATIONS;
        end
        
        
        
            
        
    end      
    
end

    